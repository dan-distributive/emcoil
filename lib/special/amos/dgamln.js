Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dgamln = dgamln;

var _d1mach = require('../../utils/fortran-utils/d1mach.js');

var _i1mach = require('../../utils/fortran-utils/i1mach.js');

// DOUBLE PRECISION FUNCTION DGAMLN(Z,IERR)
// ***BEGIN PROLOGUE  DGAMLN
// ***DATE WRITTEN        830501   (YYMMDD)
// ***REVISION DATE       830501   (YYMMDD)
// ***PORT TO ECMASCRIPT  201801   (YYYYMM)
// ***CATEGORY NO.  B5F
// ***KEYWORDS  GAMMA FUNCTION,LOGARITHM OF GAMMA FUNCTION
// ***AUTHOR (FORTRAN)  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES
// ***AUTHOR (ECMASCRIPT) ERB, KC, KINGS DISTRIBUTED SYSTEMS
// ***PURPOSE  TO COMPUTE THE LOGARITHM OF THE GAMMA FUNCTION
// ***DESCRIPTION
//
//                **** A DOUBLE PRECISION ROUTINE ****
//          DGAMLN COMPUTES THE NATURAL LOG OF THE GAMMA FUNCTION FOR
//          Z.GT.0.  THE ASYMPTOTIC EXPANSION IS USED TO GENERATE VALUES
//          GREATER THAN ZMIN WHICH ARE ADJUSTED BY THE RECURSION
//          G(Z+1)=Z*G(Z) FOR Z.LE.ZMIN.  THE FUNCTION WAS MADE AS
//          PORTABLE AS POSSIBLE BY COMPUTIMG ZMIN FROM THE NUMBER OF BASE
//          10 DIGITS IN A WORD, RLN=AMAX1(-ALOG10(R1MACH(4)),0.5E-18)
//          LIMITED TO 18 DIGITS OF (RELATIVE) ACCURACY.
//
//          SINCE INTEGER ARGUMENTS ARE COMMON, A TABLE LOOK UP ON 100
//          VALUES IS USED FOR SPEED OF EXECUTION.
//
//      DESCRIPTION OF ARGUMENTS
//
//          INPUT      Z IS D0UBLE PRECISION
//            Z      - ARGUMENT, Z.GT.0.0D0
//
//          OUTPUT      DGAMLN IS DOUBLE PRECISION
//            DGAMLN  - NATURAL LOG OF THE GAMMA FUNCTION AT Z.NE.0.0D0
//
//
// ***REFERENCES  COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
//                  BY D. E. AMOS, SAND83-0083, MAY, 1983.
// ***ROUTINES CALLED  I1MACH,D1MACH
// ***END PROLOGUE  DGAMLN
function dgamln(z) {
  var cf = void 0,
      con = void 0,
      fln = void 0,
      fz = void 0,
      gln = void 0,
      rln = void 0,
      s = void 0,
      tlg = void 0,
      trm = void 0,
      tst = void 0,
      t1 = void 0,
      wdtol = void 0,
      zdmy = void 0,
      zinc = void 0,
      zm = void 0,
      zmin = void 0,
      zp = void 0,
      zsq = void 0,
      i = void 0,
      i1m = void 0,
      k = void 0,
      mz = void 0,
      nz = void 0;
  gln = [0.00000000000000000e+00, 0.00000000000000000e+00, 6.93147180559945309e-01, 1.79175946922805500e+00, 3.17805383034794562e+00, 4.78749174278204599e+00, 6.57925121201010100e+00, 8.52516136106541430e+00, 1.06046029027452502e+01, 1.28018274800814696e+01, 1.51044125730755153e+01, 1.75023078458738858e+01, 1.99872144956618861e+01, 2.25521638531234229e+01, 2.51912211827386815e+01, 2.78992713838408916e+01, 3.06718601060806728e+01, 3.35050734501368889e+01, 3.63954452080330536e+01, 3.93398841871994940e+01, 4.23356164607534850e+01, 4.53801388984769080e+01, 4.84711813518352239e+01, 5.16066755677643736e+01, 5.47847293981123192e+01, 5.80036052229805199e+01, 6.12617017610020020e+01, 6.45575386270063311e+01, 6.78897431371815350e+01, 7.12570389671680090e+01, 7.46582363488301644e+01, 7.80922235533153106e+01, 8.15579594561150372e+01, 8.50544670175815174e+01, 8.85808275421976788e+01, 9.21361756036870925e+01, 9.57196945421432025e+01, 9.93306124547874269e+01, 1.02968198614513813e+02, 1.06631760260643459e+02, 1.10320639714757395e+02, 1.14034211781461703e+02, 1.17771881399745072e+02, 1.21533081515438634e+02, 1.25317271149356895e+02, 1.29123933639127215e+02, 1.32952575035616310e+02, 1.36802722637326368e+02, 1.40673923648234259e+02, 1.44565743946344886e+02, 1.48477766951773032e+02, 1.52409592584497358e+02, 1.56360836303078785e+02, 1.60331128216630907e+02, 1.64320112263195181e+02, 1.68327445448427652e+02, 1.72352797139162802e+02, 1.76395848406997352e+02, 1.80456291417543771e+02, 1.84533828861449491e+02, 1.88628173423671591e+02, 1.92739047287844902e+02, 1.96866181672889994e+02, 2.01009316399281527e+02, 2.05168199482641199e+02, 2.09342586752536836e+02, 2.13532241494563261e+02, 2.17736934113954227e+02, 2.21956441819130334e+02, 2.26190548323727593e+02, 2.30439043565776952e+02, 2.34701723442818268e+02, 2.38978389561834323e+02, 2.43268849002982714e+02, 2.47572914096186884e+02, 2.51890402209723194e+02, 2.56221135550009525e+02, 2.60564940971863209e+02, 2.64921649798552801e+02, 2.69291097651019823e+02, 2.73673124285693704e+02, 2.78067573440366143e+02, 2.82474292687630396e+02, 2.86893133295426994e+02, 2.91323950094270308e+02, 2.95766601350760624e+02, 3.00220948647014132e+02, 3.04686856765668715e+02, 3.09164193580146922e+02, 3.13652829949879062e+02, 3.18152639620209327e+02, 3.22663499126726177e+02, 3.27185287703775217e+02, 3.31717887196928473e+02, 3.36261181979198477e+02, 3.40815058870799018e+02, 3.45379407062266854e+02, 3.49954118040770237e+02, 3.54539085519440809e+02, 3.59134205369575399e+02];
  cf = [8.33333333333333333e-02, -2.77777777777777778e-03, 7.93650793650793651e-04, -5.95238095238095238e-04, 8.41750841750841751e-04, -1.91752691752691753e-03, 6.41025641025641026e-03, -2.95506535947712418e-02, 1.79644372368830573e-01, -1.39243221690590112e+00, 1.34028640441683920e+01, -1.56848284626002017e+02, 2.19310333333333333e+03, -3.61087712537249894e+04, 6.91472268851313067e+05, -1.52382215394074162e+07, 3.82900751391414141e+08, -1.08822660357843911e+10, 3.47320283765002252e+11, -1.23696021422692745e+13, 4.88788064793079335e+14, -2.13203339609193739e+16];
  con = 1.83787706640934548;
  // c***first executable statement  dgamln
  // ierr = 0;
  if (z <= 0.0) {
    // ierr = 1;
    return null;
  }
  if (z > 101.0) {
    // go to 10
  } else {
    nz = Math.trunc(z);
    fz = z - nz;
    if (fz > 0.0 || nz > 100) {
      //
    } else {
      return gln[nz - 1];
    }
  }
  // 10 continue
  wdtol = (0, _d1mach.d1mach)(4);
  wdtol = Math.max(wdtol, 0.5e-18);
  i1m = (0, _i1mach.i1mach)(14);
  rln = (0, _d1mach.d1mach)(5) * i1m;
  fln = Math.min(rln, 20.0);
  fln = Math.max(fln, 3.0);
  fln = fln - 3.0;
  zm = 1.8000 + 0.3875 * fln;
  mz = Math.trunc(zm) + 1;
  zmin = mz;
  zdmy = z;
  zinc = 0.0;
  if (z >= zmin) {
    // go to 20
  } else {
    zinc = zmin - nz;
    zdmy = z + zinc;
  }
  // 20 continue
  zp = 1.0 / zdmy;
  t1 = cf[0] * zp;
  s = t1;
  if (zp < wdtol) {
    // go to 40
  } else {
    zsq = zp * zp;
    tst = t1 * wdtol;
    // do 30 k=2,22
    for (k = 1; k < 22; k++) {
      zp = zp * zsq;
      trm = cf[k] * zp;
      if (Math.abs(trm) < tst) break; // go to 40
      s = s + trm;
    }
    // 30 continue
  }
  // 40 continue
  if (zinc !== 0.0) {
    // go to 50
  } else {
    tlg = Math.log(z);
    return z * (tlg - 1.0) + 0.5 * (con - tlg) + s;
  }
  // 50 continue
  zp = 1.0;
  nz = Math.trunc(zinc);
  // do 60 i=1,nz
  for (i = 1; i <= nz; i++) {
    zp = zp * (z + (i - 1));
  }
  // 60 continue
  tlg = Math.log(zdmy);
  return zdmy * (tlg - 1.0) - Math.log(zp) + 0.5 * (con - tlg) + s;
}